<html>
  <script src="https://cdn.jsdelivr.net/npm/@ruby/3.4-wasm-wasi@2.7.1/dist/browser.script.iife.js"></script>
  <textarea id="textarea">class Project
  def self.generate
    examples = [
    {
      "Stage" => {
        "program" => [ # ["CALL", "DEFINE", "argument_reporter_boolean", "argument_reporter_string_number", "color", "control_forever", "control_if", "control_if_else", "control_repeat", "control_repeat_until", "control_stop", "control_wait_until", "control_while", "coreExample_exampleOpcode", "coreExample_exampleWithInlineImage", "data_addtolist", "data_changevariableby", "data_deletealloflist", "data_deleteoflist", "data_insertatlist", "data_itemnumoflist", "data_itemoflist", "data_lengthoflist", "data_listcontainsitem", "data_replaceitemoflist", "data_setvariableto", "event_broadcast", "event_broadcastandwait", "event_whenbroadcastreceived", "event_whenflagclicked", "get_isturbowarp", "get_variable", "input", "motion_gotoxy", "operator_abs", "operator_acos", "operator_add", "operator_and", "operator_asin", "operator_atan", "operator_ceiling", "operator_contains", "operator_cos", "operator_divide", "operator_equals", "operator_floor", "operator_gt", "operator_join", "operator_length", "operator_letter_of", "operator_ln", "operator_log", "operator_lt", "operator_mathop", "operator_mod", "operator_multiply", "operator_not", "operator_or", "operator_random", "operator_round", "operator_sin", "operator_sqrt", "operator_subtract", "operator_tan", "pen_clear", "pen_menu_colorParam", "pen_pendown", "pen_penup", "pen_setPenColorParamTo", "pen_setPenColorToColor", "pen_setpensizeto", "procedures_call", "procedures_definition", "procedures_prototype", "select_broadcast", "select_key", "sensing_dayssince2000", "sensing_keypressed", "sensing_mousedown", "sensing_mousex", "sensing_mousey", "sensing_of", "sensing_of_object_menu", "sound_playuntildone", "sound_setvolumeto", "sound_sounds_menu", "translate_getTranslate", "translate_getViewerLanguage", "translate_menu_languages"]a
          define("test",["procedure","%sa","%bb"],true),
          setvar("return",arg_report("a") + bool_report("b")),
          flag,
          #arg( <= 3,"true") is error
          setvar("x",arg(4,"-1.0")),  # float
          setvar("x",arg(5,"1.0")),  # unsigned float
          setvar("x",arg(6,"1")),  # unsigned
          setvar("x",arg(7,"-1")),  # integer
          setvar("x",arg(8,"180")),  # angle
          setvar("x",arg(9,"#FF0000")),  # color
          setvar("x",arg(10,"string")), # string
          setvar("x",arg(11,"broadcast","")),  # broadcast       
          setvar("x",arg(12,"variable","")),  # variable
          setvar("x",arg(13,"list","")),  # list
          setvar("y",noshadowarg(4,"-1.0")),  # float, no shadow
          setvar("y",noshadowarg(5,"1.0")),  # unsigned float, no shadow
          setvar("y",noshadowarg(6,"1")),  # unsigned, no shadow
          setvar("y",noshadowarg(7,"-1")),  # integer, no shadow
          setvar("y",noshadowarg(8,"180")),  # angle, no shadow
          setvar("y",noshadowarg(9,"#FF0000")),  # color, no shadow
          setvar("y",noshadowarg(10,"string")), # string, no shadow
          setvar("y",noshadowarg(11,"broadcast","")),  # broadcast, no shadow       
          setvar("y",noshadowarg(12,"variable","")),  # variable, no shadow
          setvar("y",noshadowarg(13,"list","")),  # list, no shadow
          setvar("z",arg("float","-1.0")),  # float
          setvar("z",arg("unsigned float","1.0")),  # unsigned float
          setvar("z",arg("unsigned","1")),  # unsigned
          setvar("z",arg("integer","-1")),  # integer
          setvar("z",arg("angle","180")),  # angle
          setvar("z",arg("color","#FF0000")),  # color
          setvar("z",arg("string","string")), # string
          setvar("z",arg("broadcast","broadcast")),  # broadcast       
          setvar("z",arg("variable","variable")),  # variable
          setvar("z",arg("list","list")),  # list
          setvar("aa",shadow(arg(0)+arg(1))),
          
        ]# + (2..10).flat_map{
        #  [setvar("x",arg(_1,_1.to_s))]
        #}
      }
    }]
    examples[0]
  end
end</textarea>
<button id = "button">=>
</button><textarea id="output" readonly></textarea>
  <script type="text/ruby">
    require "js"
require "json"
#JS.global[:document].getElementById("textarea")[:value]
JS.global[:document].getElementById("button").addEventListener("click") do |event|

class Object
  def superclasses
    self.class.ancestors
  end
end
class Project
  def self.generate(*args)
    return "{\"Stage\":{\"isStage\":true}}"
  end
end
class Block
  def initialize(block, stats)
    @block = block
    @stats = stats
  end
  def to_s
    to_j.to_json
  end
  def to_j
    [@block, @stats.map{|k,v|
      if v.class == Array
        if v.all?{|b| b.superclasses.include?(Block)}
          {k => v.map(&:to_j)}
        else
          {k => v}
        end
      elsif v.superclasses.include?(Block)
        {k => v.to_j}
      else
        {k => v}
      end
    }.reduce({},&:merge)]
  end
  def to_a
    to_j
  end
  def +(other)
    Block.new("operator_add", {"NUM1":to_a, "NUM2":other.to_a})
  end
  def -(other)
    Block.new("operator_subtract", {"NUM1":to_a, "NUM2":other.to_a})
  end
  def *(other)
    Block.new("operator_multiply", {"NUM1":to_a, "NUM2":other.to_a})
  end
  def /(other)
    Block.new("operator_divide", {"NUM1":to_a, "NUM2":other.to_a})
  end
  def ==(other)
    BooleanBlock.new("operator_equals", {"OPERAND1":to_a, "OPERAND2":other.to_a})
  end
  def !=(other)
    !(BooleanBlock.new("operator_equals", {"OPERAND1":to_a, "OPERAND2":other.to_a}))
  end
  def >(other)
    BooleanBlock.new("operator_gt", {"OPERAND1":to_a, "OPERAND2":other.to_a})
  end
  def <(other)
    BooleanBlock.new("operator_lt", {"OPERAND1":to_a, "OPERAND2":other.to_a})
  end
  def >=(other)
    BooleanBlock.new("operator_lt", {"OPERAND1":to_a, "OPERAND2":other.to_a}).not
  end
  def <=(other)
    BooleanBlock.new("operator_gt", {"OPERAND1":to_a, "OPERAND2":other.to_a}).not
  end
  def %(other)
    Block.new("operator_mod", {"NUM1":to_a, "NUM2":other.to_a})
  end
  def [](other)
    Block.new("operator_letter_of", {"STRING":to_a, "LETTER":other.to_a})
  end
  def char_at(other)
    Block.new("operator_letter_of", {"STRING":to_a, "LETTER":other.to_a})
  end
end
class BooleanBlock < Block
  def &(other)
    BooleanBlock.new("operator_and", {"OPERAND1":self, "OPERAND2":other})
  end
  def |(other)
    BooleanBlock.new("operator_or", {"OPERAND1":self, "OPERAND2":other})
  end
  def ^(other)
    BooleanBlock.new("operator_equals", {"OPERAND1":self, "OPERAND2":other}).not
  end
  def not
    BooleanBlock.new("operator_not", {"OPERAND":self})
  end
end
class Argument < Block
  def initialize(str)
    @str = str
  end
  def to_j
    @str
  end
end
class BooleanArgument < BooleanBlock
  def initialize(str)
    if str.to_s == "true"
      @block = "operator_not"
    else
      @block = "operator_gt"
    end
    @stats = {}
  end
end
def shadow(block,shadow=true)
  Block("shadow",{"INPUT":block,"UNSHADOW":!shadow})
end
def unshadow(block)
  shadow(block,false)
end
def arg_report(str)
  Block.new("argument_reporter_string_number",{"NAME":str})
end
def bool_report(str)
  BooleanBlock.new("argument_reporter_boolean",{"NAME":str})
end
def bool(str)
  BooleanArgument.new(str)
end
class String
  def to_j
    to_s
  end
end
class Variable < Block
  def initialize(name,stats)
    @block = "get_variable"
    @stats = {"VARIABLE":name}.merge(stats)
  end
end
class List < Block
  def initialize(name,stats)
    @block = "get_list"
    @stats = {"LIST":name}.merge(stats)
  end
  def [](index)
    Block.new("data_itemoflist",{"LIST":@stats["LIST"],"INDEX":index})
  end
end
def Block(*args) = Block.new(*args)
def BooleanBlock(*args) = BooleanBlock.new(*args)
def Argument(*args) = Argument.new(*args)
def BooleanArgument(*args) = BooleanArgument.new(*args)
def Variable(*args) = Variable.new(*args)
def noshadowarg(*args)
  if args.size == 1
    Block.new("input",{"TYPE":10,"DATA1":args[0]})
  else
    if args[0].to_i == 13 || args[0] == "list"
      return List.new(args[1],{"SHADOW":false})
    end
    Block.new("input",{"TYPE":args[0],"DATA1":args[1]}.merge(args[2]? {"DATA2":args[2]} : {}))
  end
end
def arg(*args)
  if args.size == 1
    Block.new("input",{"TYPE":10,"DATA1":args[0], "SHADOW":true})
  else
    if args[0].to_i == 13 || args[0] == "list"
      return List.new(args[1],{"SHADOW":true})
    end
    Block.new("input",{"TYPE":args[0],"DATA1":args[1], "SHADOW":true}.merge(args[2]? {"DATA2":args[2]} : {}))
  end
end
#def flag() = Block.new("event_whenflagclicked",{})
#def setvar(var,val) = Block.new("data_setvariableto",{"VARIABLE":var,"VALUE":val})
#def var(var) = Block.new("get_variable",{"VARIABLE":var})
#def list(list) = Block.new("get_list",{"LIST":list})
#def repeat(times,block)
#  Block.new("control_repeat",{"TIMES":times,"SUBSTACK":block})
#end
#def abs(val)
#  Block.new("operator_abs",{"NUM1":val})
#end
#def define(*args) = procedure(*args)
#def procedure(name,procedure,warp=false)
#  Block.new("DEFINE",{"name":name,"proc":procedure,"warp":warp})
#end
#def call(name,*inputs)
#  if inputs.size == 1 && inputs[0].class == Hash
#    inputs = inputs[0]
#  end
#  Block.new("CALL",{"name":name,"inputs":inputs})
#end
#def forever(*blocks)
#  Block.new("control_forever",{"SUBSTACK":blocks})
#end
$hash = {
  "goto"=>->(*args){Block.new("control_gotoxy",{"X":args[0],"Y":args[1]})},
  "gotoxy"=>->(*args){Block.new("control_gotoxy",{"X":args[0],"Y":args[1]})},
  "deleteoflist"=>->(*args){Block.new("data_deleteoflist",{"LIST":args[0],"INDEX":args[1]})},
  "containsitem"=>->(*args){Block.new("data_listcontainsitem",{"LIST":args[0],"ITEM":args[1]})},
  "listcontainsitem"=>->(*args){Block.new("data_listcontainsitem",{"LIST":args[0],"ITEM":args[1]})},
  "insert"=>->(*args){Block.new("data_insertatlist",{"LIST":args[0],"INDEX":args[1],"ITEM":args[2]})},
  "replace"=>->(*args){Block.new("data_replaceitemoflist",{"LIST":args[0],"INDEX":args[1],"ITEM":args[2]})},
  "index"=>->(*args){Block.new("data_itemnumoflist",{"LIST":args[0],"INDEX":args[1]})},
  "length"=>->(*args){Block.new("data_lengthoflist",{"LIST":args[0]})},
  "addtolist"=>->(*args){Block.new("data_addtolist",{"LIST":args[0],"ITEM":args[1]})},
  "deleteall"=>->(*args){Block.new("data_deletealloflist",{"LIST":args[0]})},
  "clearlist"=>->(*args){Block.new("data_deletealloflist",{"LIST":args[0]})},
  "changevarby"=>->(*args){Block.new("data_changevariableby",{"VARIABLE":args[0],"VALUE":args[1]})},
  "changevar"=>->(*args){Block.new("data_changevariableby",{"VARIABLE":args[0],"VALUE":args[1]})},
  "forever"=>->(*args){Block.new("control_forever",{"SUBSTACK":args})},
  "call"=>->(name,*inputs){
    if inputs.size == 1 && inputs[0].class == Hash
      inputs = inputs[0]
    end
    Block.new("CALL",{"name":name,"inputs":inputs})
  },
  "procedure"=>->(name,procedure,warp=false){Block.new("DEFINE",{"name":name,"proc":procedure,"warp":warp})},
  "define"=>->(name,procedure,warp=false){Block.new("DEFINE",{"name":name,"proc":procedure,"warp":warp})},
  "abs"=>->(*args){Block.new("operator_abs",{"NUM1":args[0]})},
  "repeat"=>->(*args){Block.new("control_repeat",{"TIMES":args[0],"SUBSTACK":args[1]})},
  "flag"=>->(*args){Block.new("event_whenflagclicked",{})},
  "var"=>->(*args){Block.new("get_variable",{"VARIABLE":args[0]})},
  "setvar"=>->(*args){Block.new("data_setvariableto",{"VARIABLE":args[0],"VALUE":args[1]})},
  "list"=>->(*args){Block.new("get_list",{"LIST":args[0]})},
}
def flat_require(code)
  File.write("/tmp/flat_require.rb",code)
  require "/tmp/flat_require.rb"
end
$hash.each do |k,v|
  eval("def #{k}(*args)\n $hash[\"#{k}\"].call(*args)\n end")
end
ObjectSpace.each_object(Class) do |klass|
  $hash[klass.name.to_s] = ->(*args){klass.new(*args)} if klass.ancestors.include?(Block) && !$hash[klass.name.to_s] && klass.respond_to?(:new)
end

main = self
def main.method_missing(name,*args)
  if $hash[name.to_s]
    $hash[name.to_s].call(*args)
  else
    super
  end
end
eval(JS.global[:document].getElementById("textarea")[:value].to_s)

a = Project.generate(*ARGV)
if a.class == String
  a = JSON.parse(a)
end
a.each do |k,v|
  v["program"] = (v["program"] || []).map{|b| b.to_j}
end
 JS.global[:document].getElementById("output")[:value] = JSON.generate(a)
end
  </script>
</html>
